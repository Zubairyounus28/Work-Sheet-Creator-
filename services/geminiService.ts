import { GoogleGenAI, Type } from "@google/genai";
import { WorksheetData, ExamData, SectionType } from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Schema for Secondary Exam
const examSchema = {
  type: Type.OBJECT,
  properties: {
    institution: { type: Type.STRING },
    subject: { type: Type.STRING },
    grade: { type: Type.STRING },
    duration: { type: Type.STRING },
    instructions: { 
      type: Type.ARRAY, 
      items: { type: Type.STRING } 
    },
    questions: {
      type: Type.ARRAY,
      items: {
        type: Type.OBJECT,
        properties: {
          id: { type: Type.STRING },
          number: { type: Type.STRING },
          text: { type: Type.STRING },
          marks: { type: Type.NUMBER },
        },
        required: ["number", "text", "marks"],
      },
    },
  },
  required: ["institution", "subject", "questions"],
};

const cleanJson = (text: string): string => {
  if (!text) return "{}";
  let cleaned = text.trim();
  if (cleaned.startsWith("```")) {
    cleaned = cleaned.replace(/^```(json)?\s*/, "");
    cleaned = cleaned.replace(/\s*```$/, "");
  }
  return cleaned;
};

// Visual Studio Mode (Image Gen) - Now the primary method
export const generateWorksheetImage = async (base64Image: string | undefined, mimeType: string | undefined, userPrompt: string): Promise<string> => {
  // Use gemini-2.5-flash-image for full sheet generation
  const model = "gemini-2.5-flash-image";
  
  let parts: any[] = [];
  
  // Add image if provided
  if (base64Image && mimeType) {
      parts.push({ inlineData: { data: base64Image, mimeType } });
  }
  
  // Construct a strong prompt that self-enhances
  let textPrompt = `Create a high-quality, professional Montessori or primary school worksheet page.`;

  if (userPrompt && userPrompt.trim() !== "") {
     textPrompt += `\n\nUSER INSTRUCTIONS: "${userPrompt}"`;
  } else if (base64Image) {
     textPrompt += `\n\nAnalyze the provided image. Recreate a similar worksheet, but SIGNIFICANTLY IMPROVE the visual quality, clarity, and educational value.`;
  } else {
     textPrompt += `\n\nCreate a general activity worksheet for early education.`;
  }

  textPrompt += `\n\nENHANCEMENT INSTRUCTIONS (Follow Strictly):
    1. **Visual Appeal**: Use large, cute, clean line-art illustrations suitable for coloring. The style should be like a premium children's workbook.
    2. **Clarity**: Ensure text is large, legible, and friendly for children.
    3. **Enhancement**: If the user's prompt or image is simple, ADD value. 
       - If it's a math sheet, add cute counting icons. 
       - If it's writing, add tracing lines.
       - Make it "smarter" and more engaging than a plain text document.
    4. **Layout**: Organized, spacious, and aesthetic.
    5. **Output**: Return a SINGLE, complete, high-resolution worksheet image (portrait orientation).`;

  parts.push({ text: textPrompt });

  try {
    const response = await ai.models.generateContent({
      model,
      contents: { parts },
    });

    // Extract image from response parts
    if (response.candidates?.[0]?.content?.parts) {
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.data) {
                return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
            }
        }
    }
    throw new Error("No image generated by AI.");
  } catch (error) {
    console.error("Visual Studio Generation Error:", error);
    throw error;
  }
};

export const generateExamFromHandwriting = async (base64Image: string, mimeType: string): Promise<ExamData> => {
  const model = "gemini-2.5-flash";
  
  const prompt = `
    You are an expert transcriber and academic exam setter.
    
    TASK:
    Transcribe the text from this handwritten document image VERBATIM.
    
    CRITICAL FORMATTING INSTRUCTIONS:
    1. **Preserve Structure**: Keep paragraphs, line breaks, bullet points, and indentations exactly as they appear in the content. Use newline characters (\\n) to represent line breaks in the JSON string.
    2. **Content Fidelity**: Type out every single word. Do not summarize.
    3. **Lists**: If there are bulleted lists (using arrows ->, stars *, or hyphens -), preserve them in the text.
    4. **Schema mapping**: 
       - If the content is a question (e.g. "2. What is computer..."), map "2" to 'number', and the rest of the detailed answer/notes to 'text'.
       - If the content is just notes without numbers, use "1" as the number and put everything in 'text'.
    
    OUTPUT:
    Return valid JSON adhering to the provided schema. Ensure 'text' fields contain the full multi-line content with \\n characters.
  `;

  try {
    const response = await ai.models.generateContent({
      model,
      contents: {
        parts: [
          { inlineData: { data: base64Image, mimeType } },
          { text: prompt },
        ],
      },
      config: {
        responseMimeType: "application/json",
        responseSchema: examSchema,
        systemInstruction: "You are a professional scribe. Your goal is high-fidelity transcription, preserving all formatting and structure.",
      },
    });

    if (response.text) {
      return JSON.parse(cleanJson(response.text)) as ExamData;
    }
    throw new Error("No data returned from Gemini");
  } catch (error) {
    console.error("Gemini Error:", error);
    throw error;
  }
};

export const searchForWorksheets = async (query: string): Promise<{ title: string, uri: string }[]> => {
  const model = "gemini-2.5-flash";
  
  try {
    const response = await ai.models.generateContent({
      model,
      contents: `Find 5 high-quality, printable worksheet resources or ideas for: ${query}. Return a list of specific URLs to images or PDF pages if possible.`,
      config: {
        tools: [{ googleSearch: {} }],
      },
    });

    const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
    const results = chunks
      .map((chunk) => chunk.web)
      .filter((web) => web !== undefined)
      .map((web) => ({ title: web.title || "Resource", uri: web.uri || "" }));

    return results;
  } catch (error) {
    console.error("Search Error:", error);
    return [];
  }
};